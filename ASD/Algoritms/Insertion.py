def insertion_sort(arr):
    """Сортування вставками (Insertion Sort).

    Параметри:
    - arr: список який потрібно відсортувати (модифікується на місці)

    Повертає:
    - відсортований список `arr` (те саме посилання, що й аргумент)
    """

    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        # Переміщуємо елементи arr[0..i-1], які більші за key, на одну позицію вправо
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            # Строка 6: j ← j-1                   c6 * Σ(t_j - 1)
            j -= 1

        # Вставляємо ключ на правильну позицію
        arr[j + 1] = key

    return arr


# ============================================================================
# АНАЛІЗ СКЛАДНОСТІ — аналіз часової складності
# ============================================================================
"""
Аналіз алгоритму сортування вставками (Insertion Sort)

Трудомісткість (кількість базових операцій):

Строка  Код                              Вартість  Кількість разів
────────────────────────────────────────────────────────────────────
1       for i ← 2 to n                   c1        n
2       key ← A[i]                       c2        (n-1)
3       j ← i-1                          c3        (n-1)
4       while j > 0 and A[j] > key       c4        Σ(t_j) від j=2 до n
5       A[j+1] ← A[j]                    c5        Σ(t_j - 1)
6       j ← j-1                          c6        Σ(t_j - 1)
7       A[j+1] ← key                     c7        (n-1)

де t_j = кількість порівнянь на ітерації j

ЧАСОВИЙ АНАЛІЗ T(n):

T(n) = c1·n + c2·(n-1) + c3·(n-1) + c4·Σ(t_j) + c5·Σ(t_j-1) +
    c6·Σ(t_j-1) + c7·(n-1)

НАЙКРАЩИЙ ВИПАДОК (масив вже відсортований):
────────────────────────────────────────────────────────────────────
Коли масив вже відсортований: t_j = 1 для всіх j
Умова while майже не виконується (A[j] ≤ key)

T_best(n) = c1·n + c2·(n-1) + c3·(n-1) + c4·(n-1) + c7·(n-1)
T_best(n) = (c1 + c2 + c3 + c4 + c7)·n - (c2 + c3 + c4 + c7)
T_best(n) = a·n + b  →  O(n) — лінійна


НАЙГІРШИЙ ВИПАДОК (масив відсортований у зворотному порядку):
────────────────────────────────────────────────────────────────────
Коли A[j] > key для всіх порівнянь: t_j = j

Σ(t_j) від j=2 до n = Σ(j) від j=2 до n = 2+3+...+n = n(n+1)/2 - 1

T_worst(n) = c1·n + c2·(n-1) + c3·(n-1) +
          c4·(n(n+1)/2 - 1) + c5·(n(n-1)/2) +
          c6·(n(n-1)/2) + c7·(n-1)

T_worst(n) = a·n² + b·n + c  →  O(n²) — квадратична


СЕРЕДНІЙ ВИПАДОК:
────────────────────────────────────────────────────────────────────
T_avg(n) = a·n² + b·n + c  →  O(n²) — квадратична

У середньому алгоритм виконує приблизно половину порівнянь від гіршого випадку.

ВИСНОВОК:
────────────────────────────────────────────────────────────────────
│ Випадок   │ Складність │ Пояснення                      │
├───────────┼────────────┼────────────────────────────────┤
│ Найкращий │ Θ(n)       │ Масив вже відсортований        │
│ Середній  │ Θ(n²)      │ Випадкова перестановка         │
│ Найгірший │ Θ(n²)      │ Масив у зворотному порядку     │
└───────────┴────────────┴────────────────────────────────┘

Рекомендації для використання Insertion Sort:
- Підходить для малих масивів (наприклад, n < 50)
- Ефективний для майже відсортованих даних
- Зручно використовувати як частину гібридних алгоритмів (наприклад, у QuickSort для малих підмасивів)
- Стабільний алгоритм сортування
"""


# Приклад використання
if __name__ == "__main__":
    # Тестові масиви
    arr1 = [64, 34, 25, 12, 22, 11, 90]
    arr2 = [5, 2, 8, 1, 9, 3]
    arr3 = [1, 2, 3, 4, 5]  # Вже відсортований

    print("Початковий масив 1:", arr1)
    print("Відсортований:", insertion_sort(arr1.copy()))

    print("\nПочатковий масив 2:", arr2)
    print("Відсортований:", insertion_sort(arr2.copy()))

    print("\nПочатковий масив 3:", arr3)
    print("Відсортований:", insertion_sort(arr3.copy()))
